(require 'serenade-editor-state)
(require 'serenade-buffer)
(require 'serenade-log)
(require 'test-utils)
(require 'serenade-commands)

(defun serenade--handle-message (message) 
  (serenade--info (extract-json message )) 
  (let* ((callback (ht-get* message "data" "callback")) 
         (command-vector (ht-get* message "data" "response" "execute" "commandsList")) 
         (transcript (ht-get* message "transcript")) 
         (command-list (append command-vector nil))) 
    (if transcript (serenade--info (concat "received command: " transcript))) 
    (dolist (command command-list ) 
      (serenade--handle-command command message callback)) 
    (if serenade--websocket (serenade--send-completed callback))))

(defun serenade--handle-command (command message callback) 
  (serenade--set-serenade-buffer) 
  (let* ((type (ht-get*  command "type")) 
         (limited (ht-get* command "limited" )) 
         (log-info (concat type ": limited: "  (prin1-to-string limited) ))) 
    (serenade--info log-info) 
    (cond ((equal type "COMMAND_TYPE_GET_EDITOR_STATE") 
           (if (buffer-file-name) 
               (serenade--get-editor-state callback limited))) 
          ((equal type "COMMAND_TYPE_DIFF") 
           (if serenade-buffer (serenade--diff command))) 
          ((cond ((equal type "COMMAND_TYPE_EVALUATE_IN_PLUGIN") 
                  (serenade--evaluate-in-plugin command)) 
                 ((equal type "COMMAND_TYPE_COPY") 
                  (serenade--copy-target (ht-get* command "text")))
                 ;; ((equal type "COMMAND_TYPE_OPEN_FILE_LIST")
                 ;;  (serenade--open (ht-get* command "text")))
                 ((equal type "COMMAND_TYPE_SELECT") 
                  (serenade--select-target (+ 1 (or (ht-get* command "cursor") 
                                                    0)) 
                                           (+ 0 (ht-get* command "cursorEnd")))) 
                 (t (serenade--execute-default-command command)))))))

(defun serenade--diff (command) 
  (serenade--info "diffing...") 
  (serenade--update-buffer (ht-get command "source") 
                           (+(or (ht-get command "cursor") 
                                 0) 1)))

(defun serenade--evaluate-in-plugin (command) 
  (let* ((command-text (ht-get* command "text")) 
         (command-as-list (eval (car (read-from-string (concat "'"command-text))))) 
         (speeech-binding (car command-as-list) ) 
         (args (cdr command-as-list) ) 
         (converted-args (-map '(lambda (item) 
                                  (if (eq 'symbol (type-of item)) 
                                      (symbol-name item) item)) args) ) 
         (found-command  (serenade--find-voice-binding speeech-binding)) 
         (bound-fn (ht-get* found-command "command"))) 
    (apply bound-fn converted-args)))

(defun serenade--execute-default-command (command) 
  (serenade--info "executing default command") 
  (if-let* ((command-transcript (ht-get* message "data" "response" "execute" "transcript")) 
            (found-command  (serenade--find-voice-binding command-transcript)) 
            (bound-fn (ht-get* found-command "command"))) 
      (funcall bound-fn)))

(defun serenade--send-completed (callback) 
  (serenade--info "sending completed") 
  (if serenade--websocket (let* ((response (ht ("message" "callback") 
                                               ("data" (ht ("callback" callback) 
                                                           ("data" (ht ("message" "completed"))))))) 
                                 (response-json (json-serialize response))) 
                            (websocket-send-text serenade--websocket response-json))))

(provide 'serenade-handler)

;; (serenade-define-speech 'global "open buffer <name> <n>" 'switch-to-buffer)
;; (let* ((req (ht-get* (json-parse-string (load-json-commands)) "openBufferHello3")))
;; (serenade--handle-message req))
;; (defun serenade--create-argument-list-from-speech (speech arg-inputs)
;;   ;; (debug)
;;   (let* ((arg-definitions  (s-match-strings-all "<\\(.+?\\\)>" speech)))
;;     ;; (debug)
;;     (-map-indexed '(lambda (i item)
;;                      (if (string-equal (nth 1 item) "n")
;;                          (progn (debug)
;;                                 (string-to-number (nth i arg-inputs))))
;;                      (symbol-name (nth i arg-inputs)))  arg-definitions)
;;     ))
