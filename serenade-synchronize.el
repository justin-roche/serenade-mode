(require 's)
(require 'ht)

(setq serenade-directory "~/.serenade/scripts/" )

(defun serenade--clear-formatted-commands () 
  (setq serenade--formatted-commands--no-slots '()) 
  (setq serenade--formatted-commands--anonymous-slots '()) 
  (setq serenade--formatted-commands--named-slots '()))

(setq serenade-template-string "\n\n serenade.app(\"emacs\").command(`%s`, async (api, matches) => {
    api.evaluateInPlugin(`(%s)`)
});\n" )

(setq serenade-template-synchronization-fragment "\n\n let emacs = serenade.app(\"Emacs\"); \n\n
function addEmacsCommands() {
     for (const [commandName, command] of Object.entries(emacsCommands)) {
          serenade.app(\"emacs\").command(commandName, async (api, matches) => {
                await api.evaluateInPlugin(emacsCommands[commandName]);
          });
     }
}")

(defun serenade-list-to-string (l) 
  (mapconcat 'identity l "\n"))

(defun serenade--format-block--no-slots () 
  (format " let emacsCommands = { \n %s \n}" (serenade-list-to-string
                                              serenade--formatted-commands--no-slots)))

(defun serenade--format-command-without-slots (speech-and-command) 
  (format "\"%s\":\"(%s)\"," (car speech-and-command) 
          (car (cdr speech-and-command))))

(defun serenade--format-speech-matches (speech-and-command) 
  (let* ((sp (s-match-strings-all "<\\(.+?\\\)>" (car speech-and-command))) 
         (form  (s-join " "(-map '(lambda (match) 
                                    (format "%s"(format "<%%%s%%>" (nth 1 match)))) sp)))) form))

(defun serenade--format-speech (speech-and-command) 
  (s-trim (first (s-split "<" (car speech-and-command) ))))

(defun serenade--format-command-call (speech-and-command) 
  (let* ((trimmed (nth 1 speech-and-command))) trimmed))

(defun serenade--format-call-matches (speech-and-command) 
  (let* ((sp (s-match-strings-all "<\\(.+?\\\)>" (car speech-and-command))) 
         (form  (mapconcat 'identity (-map '(lambda (match) 
                                              (format "${matches.%s}"  (nth 1 match))) sp) " ")))
    form))

(defun serenade--format-command-with-named-slots (speech-and-command)
  ;; (ignore-errors) ;; (debug)
  (format
   "serenade.app(\"emacs\").command(`%s %s`, async (api, matches) => { api.evaluateInPlugin(`(%s %s )`) });"
   ;; "a" "a" "a"
   (serenade--format-speech speech-and-command) 
   (serenade--format-speech-matches speech-and-command) 
   (serenade--format-command-call speech-and-command) 
   (serenade--format-call-matches speech-and-command)))

(defun serenade--format-command (speech-and-command)
  ;; determine command type and add to appropriate command list
  ;; (debug)
  (cond ((s-match "<.+>" (car speech-and-command )) 
         (add-to-list 'serenade--formatted-commands--named-slots
                      (serenade--format-command-with-named-slots speech-and-command)))
        ;; ((s-match "%s" speech)
        ;;  (add-to-list 'serenade--formatted-commands--anonymous-slots
        ;;               (serenade--format-command-with-anonymous-slots speech e)))
        ('t (add-to-list 'serenade--formatted-commands--no-slots
                         (serenade--format-command-without-slots speech-and-command)))))

(defun serenade--format-commands () 
  (serenade--clear-formatted-commands) 
  (ht-each '(lambda (key value) 
              (ht-each '(lambda (speech binding) 
                          (let* ((command (ht-get* binding "command"))) 
                            (serenade--format-command (list speech command )))) value))
           serenade-mode-maps))

(defun serenade-synchronize () 
  (serenade--format-commands) 
  (let* ((name-input "emacsAutogenerated.js") 
         (fpath (concat serenade-directory name-input))) 
    (with-temp-file fpath
      ;; (insert (serenade--format-block--no-slots))
      (insert (serenade-list-to-string serenade--formatted-commands--named-slots))
      ;; (insert (serenade-list-to-string serenade--formatted-commands--anonymous-slots))
      ;; (insert serenade-template-synchronization-fragment)
      (find-file fpath))))

(serenade-define-speech 'global "b <z><x>" 'b)

;; (serenade-synchronize)
;; ( serenade--format-commands )

(provide 'serenade-synchronize)
