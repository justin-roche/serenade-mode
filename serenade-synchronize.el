(require 's)

(setq serenade-commands (ht))
(setq serenade-formatted-commands--no-slots '())
(setq serenade-formatted-commands--anonymous-slots '())
(setq serenade-formatted-commands--named-slots '())

;; (serenade-set-commands '(("reveal" . reveal-in-osx-finder)
;;                          ("yas reload" . yas-reload-all)))
(serenade-set-command "describe face" 'describe-face)

(serenade-set-command "select window %s %s %s" 'select-window)
(serenade-set-command "org promote <level>" 'org-do-promote)
(serenade-set-command "promote <level>" 'org-do-promote)
;; (serenade-set-command "org promote <level>" 'org-do-promote)
(serenade-set-command "uncomment-region" 'uncomment-region)

(setq serenade-directory "~/.serenade/scripts/" )

(setq serenade-template-string "\n\n serenade.app(\"emacs\").command(`%s`, async (api, matches) => {
    api.evaluateInPlugin(`(%s)`)
});\n" )

(setq serenade-template-synchronization-fragment "\n\n let emacs = serenade.app(\"Emacs\"); \n\n
function addEmacsCommands() {
     for (const [commandName, command] of Object.entries(emacsCommands)) {
          serenade.app(\"emacs\").command(commandName, async (api, matches) => {
                await api.evaluateInPlugin(emacsCommands[commandName]);
          });
     }
}")

(defun serenade-list-to-string (l) 
  (mapconcat 'identity l "\n"))

(defun serenade-format-block--no-slots () 
  (format " let emacsCommands = { \n %s \n}" (serenade-list-to-string
                                              serenade-formatted-commands--no-slots)))

(defun serenade-get-command-without-slots (v e) 
  (format "  \"%s\": \"(%s)\"," v e))

(defun serenade-get-api-call (e s) 
  (concat (format "%s " e ) 
          (mapconcat 'identity (-map (lambda(slot-name) 
                                       (format "${matches.%s} " slot-name)) s) " ")))

(defun serenade-get-named-slots (v) 
  (-map '(lambda (match) 
           (s-replace ">" "" (s-replace "<" "" match ))) 
        (s-match "<.+>" v)))

(defun serenade-get-unnamed-slots (v) 
  (let* ((match-count (s-count-matches "%s" v)) 
         (matches '())) 
    (dotimes (i match-count) 
      (push (concat "match"(number-to-string (+ 1 i)) ) matches)) 
    (reverse matches)))

(defun serenade-get-command-name-with-anonymous-slots (e s) 
  (let* ((clean-name (s-replace "%s" "" e)) 
         (wrapped-slots (-map '(lambda (slot) 
                                 (concat "<%" slot "%>")) s))) 
    (concat clean-name ( mapconcat 'identity wrapped-slots " "))))

(defun serenade-get-command-with-named-slots (v e ) 
  (let* ((formatted-api-call (serenade-get-api-call e (serenade-get-named-slots v))) 
         (formatted (format serenade-template-string (s-replace "<" "<%"(s-replace ">" ">" v))
                            formatted-api-call)))
     formatted))

(defun serenade-get-command-with-anonymous-slots ( v e) 
  (let* ((slots (serenade-get-unnamed-slots v)) 
         (formatted-command-name  (serenade-get-command-name-with-anonymous-slots v slots)) 
         (formatted-api-call (serenade-get-api-call e slots)) 
         (formatted (format serenade-template-string formatted-command-name formatted-api-call)))
    formatted))
                                        ;===================================== loop ====================================

(defun serenade-format-command (e v)
  ;; determine command type and add to appropriate command list
  (cond ((s-match "<.+>" v) 
         (add-to-list 'serenade-formatted-commands--named-slots
                      (serenade-get-command-with-named-slots v e)))
        ((s-match "%s" v) 
         (add-to-list 'serenade-formatted-commands--anonymous-slots
                      (serenade-get-command-with-anonymous-slots v e)))
        ('t (add-to-list 'serenade-formatted-commands--no-slots (serenade-get-command-without-slots
                                                                 v e)))))

(defun serenade-format-commands () 
  (ht-each '(lambda (v e) 
              (serenade-format-command e v)) serenade-commands))

(defun serenade-synchronize () 
  (serenade-format-commands) 
  (let* ((name-input "emacsAutogenerated.js") 
         (fpath (concat serenade-directory name-input))) 
    (with-temp-file fpath
      ;;     ;;
      (insert (serenade-format-block--no-slots)) 
      (insert (serenade-list-to-string serenade-formatted-commands--named-slots)) 
      (insert (serenade-list-to-string serenade-formatted-commands--anonymous-slots)) 
      (insert serenade-template-synchronization-fragment) 
      (find-file fpath))))

(serenade-synchronize)
